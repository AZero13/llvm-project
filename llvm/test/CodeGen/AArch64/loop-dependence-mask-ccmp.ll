; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=aarch64 -mattr=+sve2 -verify-machineinstrs -stop-after=finalize-isel %s -o - | FileCheck %s

; Regression test for a bug where getTargetConstant(0) was used instead of
; getConstant(0) in ScalarizeVecRes_LOOP_DEPENDENCE_MASK, causing instruction
; selection to incorrectly generate CCMPXr (register form) with an immediate
; operand instead of CCMPXi (immediate form).
;
; Before the fix, this produced invalid machine code that failed verification:
;   CCMPXr %2:gpr64common, 0, 4, 13, ...
;                          ^ literal immediate in register operand slot
;
; Error: "*** Bad machine code: Expected a register operand. ***"
;
; After the fix, it correctly produces:
;   CCMPXi %2:gpr64common, 0, 4, 13, ...
;
; This test verifies that CCMPXi (immediate form) is selected, not CCMPXr.
; Assembly output would look identical for both, so we must check machine IR.

define <1 x i1> @test_war_mask_ccmp(ptr %a, ptr %b) {
; CHECK-LABEL: name: test_war_mask_ccmp
; CHECK: bb.0.entry:
; CHECK:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x1
; CHECK:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
; CHECK:   [[SUBSXrr:%[0-9]+]]:gpr64common = SUBSXrr [[COPY1]], [[COPY]], implicit-def dead $nzcv
; CHECK:   [[SUBSXri:%[0-9]+]]:gpr64 = SUBSXri [[SUBSXrr]], 0, 0, implicit-def $nzcv
; CHECK:   CCMPXi [[SUBSXrr]], 0, 4, 13, implicit-def $nzcv, implicit $nzcv
; CHECK:   [[CSINCWr:%[0-9]+]]:gpr32 = CSINCWr $wzr, $wzr, 1, implicit $nzcv
; CHECK:   $w0 = COPY [[CSINCWr]]
; CHECK:   RET_ReallyLR implicit $w0
entry:
  %0 = call <1 x i1> @llvm.loop.dependence.war.mask.v1i1(ptr %a, ptr %b, i64 1)
  ret <1 x i1> %0
}

define <1 x i1> @test_raw_mask_ccmp(ptr %a, ptr %b) {
; CHECK-LABEL: name: test_raw_mask_ccmp
; CHECK: bb.0.entry:
; CHECK:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x1
; CHECK:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
; CHECK:   [[SUBSXrr:%[0-9]+]]:gpr64common = SUBSXrr [[COPY1]], [[COPY]], implicit-def dead $nzcv
; CHECK:   [[SUBSXri:%[0-9]+]]:gpr64 = SUBSXri [[SUBSXrr]], 0, 0, implicit-def $nzcv
; CHECK:   CCMPXi [[SUBSXrr]], 0, 4, 13, implicit-def $nzcv, implicit $nzcv
; CHECK:   [[CSINCWr:%[0-9]+]]:gpr32 = CSINCWr $wzr, $wzr, 1, implicit $nzcv
; CHECK:   $w0 = COPY [[CSINCWr]]
; CHECK:   RET_ReallyLR implicit $w0
entry:
  %0 = call <1 x i1> @llvm.loop.dependence.raw.mask.v1i1(ptr %a, ptr %b, i64 1)
  ret <1 x i1> %0
}

declare <1 x i1> @llvm.loop.dependence.war.mask.v1i1(ptr, ptr, i64)
declare <1 x i1> @llvm.loop.dependence.raw.mask.v1i1(ptr, ptr, i64)

